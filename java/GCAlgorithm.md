# GC 알고리즘
JVM 에서는 GC 를 수행하는 기본 알고리즘 4가지가 있다. 

## The serial garbase collector
**시리얼 가비지 컬렉터**는 가장 단순하며, 힙을 처리하기 위해 단일 스레드를 사용한다. 마이너나 풀GC에서 힙이 처리되면서 모든 애플리케이션 스레드가 
멈추고, 풀GC가 일어나는 동안 올드 제너레이션은 완전히 압축된다. 
> 올드 제너레이션의 GC 는 mark-sweep-compact 알고리즘은 사용

`-XX:+UseSerialGC` 플래스를 이용해서 사용할 수 있고, 시리얼 컬렉터가 디폴트인 시스템에서 다른 GC 알고리즘을 명시하면 비활성화 된다. 
> 클라이언트 클래스 머신(단일 프로세서 머신이나 윈도우의 32비트 JVM)에서 디폴트

## Throughput collector
> 여러 개의 스레드를 사용하기 때문에 병렬 컬렉터라고도 부른다. 

**처리율 컬렉터**는 기본적인 알고리즘은 시리얼 컬렉터와 같지만, 영 제너레이션을 수집할 때 스레드응 여러 개 사용한다. 
이로인해 시리얼 컬렉터를 사용할 때보다 마이너 GC가 더 빨라진다. 
올드 제너레이션을 처리할 때도 여러 개의 스레드를 이용할 수 있는데, 이건 JDK7u4 이후의 릴리즈 버전에서 디폴트 기능이다. 
`-XX:+UseParallelOldGC` 플래그를 명시하면, JVM 초기 버전에서도 이 기능을 이용할 수 있다. 

처리율 컬렉터는 마이너든 풀이든 GC가 일어나는 경우, 모든 애플리케이션 스레드를 멈추고, 풀GC에서는 올드 제너레이션을 완전히 압축한다. 
풀GC 는 mark-summary-compaction 알고리즘에 의해 수행된다. 
대부분 디폴트로 사용하지만, `-XX:+UseParallelGC -XX:+UseParallelOldGC` 플래그를 사용하여 활성화할 수 있다. 
> 서버 클래스 머신(멀티 CPU 유닉스 머신과 64비트 JVM)에서 디폴트

## CMS Collector (Concurrent Mark Sweep)
**CMS 컬렉터**는 처리율과 시리얼 컬렉터에서 풀GC 주기와 관련해서 생기는 긴 중지 현상을 없애도록 설계되었다. 
CMS는 마이너 GC 동안 애플리케이션 스레드를 전부 중지시키고 여러 개의 스레드로 실행된다. 

CMS는 풀GC를 수행하면서 애플리케이션 스레드를 멈추지않는다. 주기적으로 올드 제너레이션을 통해 객체를 확인하고, 미사용 객체(쓰레기 객체)를 
수집하는 데에 하나 이상의 백그라운드 스레드를 사용한다. 덕분에 CMS 는 **저중지 컬렉터**가 될 수 있다. 
stop-the-world 시간이 굉장히 짧기 때문에, 모든 애플리케이션의 응답 속도가 매우 중요할 때 사용한다.

단 트레이드오프로 CPU 를 더 많이 사용하고, compaction 단계가 기본적으로 제공되지 않는다. 
애플리케이션 스레드가 수행되면서 동시에 백그라운드 GC스레드가 힙을 체크할 수 있을 정도의 CPU가 충분히 확보되어야 한다. 또한 
compaction을 하지 않는 다는 것은 힙이 단편화 될 수 있다는 사실을 의미한다. 
조각난 메모리가 많아서 compaction 작업을 수행할 경우, 다른 GC 방식의 stop-the-world 보다 시간이 더 많이 소요될 수 있기 때문에 
compaction 작업이 얼마나 자주, 길게 수행되는지 확인해야 한다. 
> CMS 는 백그라운드 스레드가 작업을 완료하는 데 충분한 CPU가 없거나, 힙이 객체를 할당하는 데 단편화가 너무 많이 된다면 
시리얼 컬렉터의 동작을 되돌린다. 이 경우 단일 스레드를 사용해서 올드 제너레이션을 비우고 압축하기 위해 
모든 애플리케이션 스레드가 중단된다. 

`-XX:UseConcMarkSweepGC -XX:+UseParNewGC` 플래그를 명시하여 사용할 수 있다.
> 둘다 디폴트는 `false`

## G1 collector(Garbase First)
G1은 중지 시간을 최소한으로하면서 큰 힙(약 4GB 이상)을 처리할 수 있도록 설계되었다. 제너레이션 기반의 컬렉터라는 사실은 동일하지만, 힙을 
여러 영역으로 나눈다는 점에서 차이가 있다. 
> 힙 영역을 작은 단위로 쪼개서 각 지역들을 eden, survivor, old 영역으로 사용 가능

이 영역의 일부는 영 제너레이션을 구성하게 되고, 영 제너레이션은 여전히 모든 애플리케이션 스레드를 멈추고 올드 제너레이션이나 서바이버 스페이스로 
살아있는 객체들을 전부 이동시키면서 수집된다. 다른 알고리즘과 마찬가지로 여러 스레드를 이용해서 처리된다. 

G1은 동시 병렬 컬렉터로, 애플리케이션 스레드를 중단시킬 필요가 없는 백그라운드 스레드로 올드 제너레이션을 처리한다. 
G1은 힙 메모리에서 marking 을 수행하면서 어떤 지역이 가장 많이 비었는 지 알 수 있게 된다. mark 단계가 종료된 후, 
G1은 거의 비어있는 영역을 알게 되며, 그 지역부터 메모리 회수를 시작한다(먼저 많은 여유 공간이 생성되는 영역). 
G1 은 일시정지 예측 모델을 사용해서 사용자가 정의한 일시중지 시간을 기반으로 수집할 영역의 수를 정한다.
> 그래서 이름이 Garbase-First .. 쓰레기가 가득 찬 힙 영역에 집중하여 수집하기 때문에  ...

G1에 의해 교체를 해야하는 지역으로 확인된 곳은 evacuation(배출?대피?)에 의해 GC 처리된다. G1 은 하나 이상의 지역으로부터 객체를 복사하여 
하나의 지역에 넣고, 이 과정에서 메모리를 비우고 최적화한다. 따라서 부분적이지만 힙을 압축할 수 있고, 힙의 단편화가 일어날 수는 있지만 그 확률이 훨씬 낮다. 
앞서 말했듯이 이 evacuation 은 병렬처리되기 때문에 stop-the-world 의 시간이 줄어든다. 

다른 GC 알고리즘과 비교했을 때, 큰 이점이 있는 부분이라고 할 수 있다.  
- CMS 가비지 수집은 압축을 수행하지 않음
- ParallelOld 가비지 수집은 전체 힙 압축을 수행하므로 상당한 일시 중지 시간이 발생

CMS와 마찬가지로 풀GC 주기를 피하기 위한 프레이드 오프는 CPU 시간이다. 
G1 은 `-XX:UseG1GC` 플래그를 명시하여 사용할 수 있다.
> 디폴드는 `false`
