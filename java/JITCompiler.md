# JIT Compiler

## Overview
### 인터프리터
인터프리터는 각 라인이 실행되면서 프로그램의 각 코드를 한 줄씩 바이너리 코드로 해석한다. 
인터프리터 언어로 작성된 프로그램은 이식성이 높다는 장점이 있다. 하지만 항상 코드를 반복해서 해석하기 때문에 느리다. 
> 인터프리터는 루프 내에서 실행될 때 코드의 각 줄을 다시 해석한다. 컴파일된 코드는 매 번 되풀이하며 해석되지 않는다. 

### 컴파일러
인터프리터가 프로그램을 한 줄씩 해석하는 반면에, 컴파일러는 프로그램을 통째로 해석하고 해석된 코드를 실행시킨다. 
처음 해석에는 시간이 더 소요될 수 있지만, 한 번 컴파일된 코드는 다시 해석될 필요가 없으므로 실행에서는 더 빠르다. 

JVM의 JIT 컴파일러는 인터프리터와 컴파일러 둘 다의 특성을 이용한다.

컴파일 타임에 `.java` 파일은 `.class` 형태의 바이너리 파일로 컴파일된다. JVM은 런타임에 클래스 파일을 로드하고 각 바이트 코드를 해석하고 계산을 수행한다. 
JIT 컴파일러는 런타임에 바이트코드를 네이티브 머신 모드로 컴파일하여 성능을 향상시킨다. 
JIT 컴파일러는 java 메소드가 호출될 때 활성화되며, 해당 메소드의 바이트코드를 네이티브 머신 코드로 "Just in time(적시에)" 컴파일하여 실행한다. 
컴파일된 메소드는 JVM 에서 인터프리팅 되지 않고 직접 호출되어 실행된다. 

## 핫스팟 컴파일
JVM이 코드를 실행할 때 바로 코드 컴파일을 실행하지 않는데 그 이유는 다음과 같다. 
- 코드가 한번만 실행된다면, 코드를 컴파일해서 실행하는 것보다 자바 바이트 코드를 
인터프리팅하는 것이 더 효율적일 수 있기 때문이다. 반면 자주 호출되는 메소드거나 반복적으로 실행되는 루프하면 컴파일할 가치가 있다. 
- JVM 은 특정 메소드나 루프를 실행시키는 횟수가 많아질 수록 해당 코드에 대한 정보를 많이 갖게 된다. 따랏서 JVM 은 이 정보를 통해 코드를 컴파일할 때 
**최적화**를 많이 적용할 수 있게 된다.

## 컴파일러 튜닝

### 컴파일 모드 
JIT 컴파일러는 크게 두 가지 형태로 사용된다.  

클라이언트 컴파일러는 서버 컴파일보다 컴파일 시작 속도가 빠르다. 따라서 초기 실행은 클라이언트 컴파일러가 더 빠르다. 
하지만 서버 컴파일러는 기다리는 시간 동안 '정보'를 얻어서 컴파일된 코드에 최적화를 적용한다. 결국 서버 컴파일러가 만들어낸 코드는 
클라이언트 컴파일러가 만든 코드보다 빠를 것이다. 

따라서 두 컴파일러 선택에 따른 트레이드 오프는 **프로그램이 수행되는 기간**과 **초기 스타트업 시간의 중요도**이다. 
이 둘의 특성을 혼합한 **티어드 컴파일**방식이 있다. 티어트 컴파일을 이용하면 먼저 클라이언트 컴파일로 컴파일 한 후에, 
많이 쓰이게 되면 서버 컴파일러로 다시 컴파일 된다. 티어드 컴파일 옵션을 사용하려면 `-XX:+TieredCompliation` 플래그(디폴트 false)를 추가하면 된다. 
> Java7 에서는 티어드 컴파일에 불안정적인 요소가 있고, JVM 코드 캐시 크기를 초과하기 쉬운 문제가 있음

```shell
$> java -client -XX:+TieredCompilation other_args
```

### 코드 캐시 튜닝
JVM 의 코드 캐시가 가득차면 JVM은 더 이상 코드를 컴파일 할 수 없다. 코드 캐시내에는 어셈블리 언어 명령어들이 있다. 
코드 캐시가 너무 작다면, 일부 핫스팟은 컴파일 되지만 다른 영역은 컴파일 하지 못하게 되고 결국 애플리케이션은 자주 호출되는 코드임에도 불구하고 
인터프리팅된 코드를 실행할 수 밖에 없게 된다. 코드 캐시로 인한 이슈는 클라이언트 컴파일러나 티어드 컴파일러는 사용할 때 더 자주 발생한다. 
그렇지만 대상 머신에서 사용 가능한 자원에 따라 코드 캐시의 크기는 제한된다. 예를 들어 JVM 이 32bit 라면 프로세스 전체 크기는 4GB를 초과할 수 
없는데, 여기에는 자바 힙, JVM 자체 모든 코드를 위한 공간, NIO로 직접 애플리케이션이 할당하는 네이티브 메모리, 코드 캐시 등이 포함된다. 
따라서 코드 캐시는 무한하게 설정할 수 없다. 

코드 캐시의 최대 크기는 `-XX:ReservedCodeCacheSize=N` 플래그를 통해 설정할 수 있다. 
> 캐시 리사이징은 백그라운드에서 일어남

### 컴파일 임계치
**얼마나 자주 코드가 실행되었는가** 에 초점을 맞추어서, 일정한 횟수만큼 실핸된 코드는 컴파일 임계치에 도달했다고 보고 컴파일러는 
코드를 컴파일하기에 충분한 정보가 쌓였다고 본다. 

컴파일은 JVM 내에 있는 메소드가 호출된 횟수, 메소드의 루프를 빠져나오기까지 반복한 횟수에 대한 카운터 두 정보를 기반으로 한다. 
JVM은 자바 메소드를 실행할 때 두 카운터의 합계를 확인하여 컴파일될 자격이 있는지 여부를 결정한다. 

`-XX:CompilerThreshold=N` 플래그로 임계치를 조절할 수 있으며, 클라이언트 컴파일에서 N의 디폴트는 1,500, 서버 컴파일러는 10,000 이다.

### 컴파일 프로세스 점섬
직접 튜닝은 아니지만, `-XX:+PrintCompliation` 옵션을 통해 메소드가 컴파일될 때마다 JVM 이 컴파일된 대상에 대한 정보를 출력하도록 할 수 있다. 
