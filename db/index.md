# Index
Index 는 데이터베이스의 성능에 있어서 중요한 부분이다. MySQL 에서는 인덱싱이나 검색 방식에 따라 스토리지 엔진을 선택해야 할 수도
있다. 

## Index 란
DBMS 가 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 많이 걸린다. 
그래서 칼럼의 값과 해당  해코드가 저장된 주소를 key-value 쌍으로 인덱스를 만들어 두어 빠른 검색이 가능하도록 한다. 
또한 인덱스가 많아져도 최대한 빠르게 찾아낼 수 있게 컬럼의 값을 주어진 순서대로 미리 **정렬**하여 보관해둔다. 

당연하세도 데이터가 저장될때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬되어 있기 때문에 빠르게 원하는 값을 
가져오는 것이 가능하다. 따라서 DBMS 의 인덱스가 많은 테이블은 `INSERT`, `UPDATE`, `DELETE` 문장의 처리는 느려지지만, SELECT 문장은 
매우 빠르게 처리하는 것이 가능하다. 

- DBMS 에서 인덱스는 저장 성능을 희생하고, 대신 데이터의 읽기 속도를 높이는 기능
- 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 얼마나 희생 가능하고, 읽기 속도를 얼마나 더 빠르게 해야하는지 여부에 따라 결정

## B-Tree 인덱스
- 컬럼의 값을 변형하지 않고, 원래의 값을 인덱싱하는 알고리즘
- 대부분의 인덱스는 거의 B-Tree 를 사용

B-Tree 는 트리 구조의 최상위에 하나의 **루트노드**가 존재하고 그 하위에 자식 노드가 붙어있는 형태이다. 가장 하위에 있는 노드를 **리프 노드**라고 
하고, 루트도 아니고 리프도 아닌 중산의 노드를 **브랜치 노드**라 한다. DB 에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 
인덱스의 리프 노드는 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있다. 
> 이때 인덱스의 키 값은 모두 정렬되어 있지만 데이터 파일의 레코드는 정렬되어 있지 않다. 

B-tree 인덱스는 인덱스를 구성하는 칼럼의 크기와 레코드 건수, 유니크 인덱스 키 값의 갯수 등에 의해 검색이나 변경 작업 성능이 영향을 받는다. 

#### 인덱스 키 추가
B-Tree 에 저장될 떄는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색해야 한다. 
저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree 의 리프 노드에 저장한다. 
리프노드가 꽉 차서 더 이상 저장할 수 없을 때는 리프 노드가 split 되어야 하는데 이는 상위의 브랜치 노드까지 처리 되어야 하는 과정이라 
상대적으로 B-Tree 는 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 든다고 한다.  

#### 인덱스 키 삭제
해당 키 값이 저장된 B-Tree 의 리프 노드를 찾아서 그냥 삭제 마크만 하면 된다. 삭제 마킹된 인덱스 공간은 그대로 방치되거나 재활용할 수 있다. 
인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 이 작업 역시 디스크 I/O 가 필요한 작업니다. 

#### 인덱스 키 변경
인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree 의 키 값이 변경되는 경우에 
단순히 인덱스 상의 키 값만 변경하는 것은 불가능 하고, 먼저 키 값을 삭제하고 다시 키 값을 추가하는 형태로 처리된다. 

#### 인덱스 키 검색
검색 작업은 B-Tree 의 루트 노드부터 시작해 브랜치를 거쳐 최종 리프노드 까지 이동하면서 비교 작업을 수행한다(**트리 탐색 Tree traversal**).
B-Tree 인덱스를 이용한 검색은 완전히 일치하거나 값의 앞부분만 일치하는 경우에 사용할 수 있고, `!=`, `<>` 비교나 값의 뒷 부분이 일치하는 경우에는 
사용할 수 없다. 또한 인덱스의 키 값을 변형하여 비교하는 경우에는 인덱스를 사용 할 수 없다. 

## Hash 인덱스
- 컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원
- 값을 변형해서 인덱싱하므로, prefix 일치와 같이 값의 일부만 검색하고자 할 때는 해시 인덱스 사용 불가
- 메모리 기반의 데이터베이스에서 많이 사용

해시 인덱스는 동등 비교 검색에는 최적화 되어 있지만 범위를 검색하거나 정렬된 결과를 가져오는 목적으로는 사용할 수 없다. 
일반적인 DBMS 에서 해시 인덱스는 메모리 기반의 테이블에 주로 구현되어 있고, 디스크 기반의 대용량 테이블로는 거의 사용되지 않는다는 특징이 있다. 
해시 인덱스 알고리즘은 테이블의 인덱스 뿐 아니라, InnoDB 의 버퍼풀에서 빠른 레코드 검색을 위한 Adaptive Hash Index 로 사용되기도 하고, 
오라클과 같은 DBMS 에서는 조인에 사용되기도 한다.

해시 인덱스는 실제 키 값과는 상관없이 인덱스의 크기가 작고 검색이 빠르다. 
> 원래의 키 값을 저장하는 것이 아니라 해시 함수의 결과를 저장하기 때문에 B-tree 인덱스보다 상당히 크기를 줄일 수 있음

또한 해시 인덱스는 트리 형태의 구조가 아니므로 검색하고자 하는 값을 주면 해시 함수를 거쳐서 찾고자 하는 키 값이 포함된 버켓을 알아낼 수 있다. 
> 트리 내에서 여러 노드를 읽어서 레코드 주소를 알아내는 B-tree 보다 빠르게 검색이 가능함

#### 작업 범위 제한 조건으로 해시 인덱스를 사용하는 쿼리
동등 비교 조건으로 값을 검색하면 해시 인덱스의 장점을 그대로 이용할 수 있다.
````SQL
SELECT .. FROM tableName WHERE column = 'query';
SELECT .. FROM tableName WHERE column <=> 'query';
SELECT .. FROM tableName WHERE column IN ('query', 'query2');
SELECT .. FROM tableName WHERE column IS NULL;
SELECT .. FROM tableName WHERE column IS NOT NULL;
````
> `IN` 연산자도 결국 여러 개의 동등 비교로 풀어서 처리하기 때문에 같은 효과를 얻을 수 있음.</br>
> `<=>` 연산자(NULL-Safe Equal)는 비교 양쪽의 값이 `NULL` 이 있을 때는 제외하고는 `=` 연산자와 동일

#### 해시 인덱스를 전혀 사용하지 못하는 쿼리
크다 또는 작다 기반의 검색은 해시 인덱스를 사용할 수 없다. 범위비교나 부정형 비교는 해시인덱스를 사용할 수 없다. 
````SQL
SELECT .. FROM tableName WHERE column >= 'query';
SELECT .. FROM tableName WHERE column BETWEEN 100 AND 200;
SELECT .. FROM tableName WHERE column LIKE 'query%';
SELECT .. FROM tableName WHERE column <> 'query';
````
다중 컬럼으로 생성된 해시 인덱스에서도 모든 칼럼이 동등 조건으로 비교되는 경우에만 인덱스를 사용할 수 있다. 

MySQL MEMORY 스토리지 엔진에서는 특별히 인덱스 알고리즘은 명시하지 않으면 기본적으로 해시 인덱스가 적용된다. 

## Fractal-Tree 인덱스
- B-Tree 의 단점을 보완하기 위한 알고리즘
- 값을 변형하기 않고 인덱싱하며 범용적인 목적으로 사용하는 점은 B-Tree 와 유사하지만, 데이터가 저장되거나 삭제될 때 처리비용을 상당히 줄일 수 있음

