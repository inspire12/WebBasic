# Kafka
카프카는 데이터 단위를 보내는 측(publisher, producer)에서 토픽이라는 각각의 메시지 저장소에 데이터를 저장하면, 가져가는 측(subscriber, consumer)이 
원하는 토픽에서 데이터를 가져가는 것이 기본 동작 방식이다. 
> 중앙에 메시징 시스템 서버를 두고 메시지를 publish 하고 subscribe 하는 형태의 통신은 pub/sub 모델이라고 한다. 

## 카프카의 특징

### 프로듀서와 컨슈머의 분리
카프카는 메시지를 보내는 역할과 받는 역할이 완전히 분리된 pub/sub 방식을 적용했다. Publisher 는 수신자가 정해져있지 않은 상태의 메시지를 발행하고, 
구독을 신청한 Subscriber 만 정해진 메시지를 받을 수 있다. 
이 때, Publisher 와 마찬가지로 Subscriber 도 발신자 정보 없이 원하는 메시지만 수신할 수 있다. 
이렇게 각자의 역할이 완벽하게 분리되면서, 어느 한쪽 시스템에 문제가 발생하더라도 연쇄작용이 발생할 확률을 낮출 수 있게 되었다. 

### 멀티 프로듀서, 멀티 컨슈머
카프카는 하나의 토픽에 여러 프로듀서나 컨슈머들이 접근 가능한 구조로 되어있다. 프로듀서와 컨슈머는 각각 하나 이상의 토픽으로 메시지를 보내고, 
가져오는 것이 가능하다. 

### 디스크에 메시지 저장
기존의 메시징 시스템과 카프카의 가장 다른 특징 중 하나는 바로 디스크에 메시지를 저장하고 유지하는 것이다. 일반적인 메시징 시스템은 컨슈머가 메시지를 
읽어가면 큐에서 바로 메시지를 삭제한다. 반면에 카프카는 컨슈머가 메시지를 읽어가더라도 정해져있는 보괁누기 동안 디스크에 메시지를 저장해준다. 
덕분에 일시적으로 트래픽이 폭주하는 등의 문제로 컨슈머의 처리가 늦어지더라도 메시지는 디스크에 보관되어있기 때문에 컨슈머는 손실없이 메시지를 
가져갈 수 있다. 

디스크에 기반한 영속적인 저장 방식음 사용함에도 페이지 캐시를 활용하여 높은 처리량을 제공하는 인메모리 방식에 가깝다.
> 메모리에 별도의 캐시를 구현하지 않고 OS 의 페이지 캐시에 위임하여 OS 가 알아서 서버의 유휴 메모리를 페이지 캐시로 사용하여 앞으로 필요할 것으로 
예상되는 메시지들을 미리 읽어들여서 디스크의 읽기 성능을 향상 시킨다. 카프카 프로세스가 직접 캐시를 관리하지 않고 OS 에 위임하기 때문에 프로세스를 
재시작하더라도 OS 의 페이지 캐시는 그대로 남아있기 때문에 프로세스 재시작 후 캐시를 워밍업할 필요가 없다는 장점이 있다. 

### 확장성
하나의 카프카 클러스터는 3대의 브로커로 시작해서 수십대의 브로커로 확장이 가능하다. 확장 작업은 카프카 서비스의 중단없이 온라인 상태에서 작업이 
가능하다. 

### 높은 성능
카프카는 분산 처리, 배치 처리 등 다양한 기법을 통해 고성능을 유지한다. 
- 카프카는 단순한 메시지 헤더를 지닌 TCP 기반의 프로토콜을 사용해서 프로토콜에 의한 오버헤드를 감소시켰다. 

#### 배치처리
- Producer 가 broker 에게 다수의 메시지를 전송할 때 각 메시지를 개별적으로 전송해야하는 기존 메시징 시스템(ActiveMQ, RabbitMQ)과는 달리, 
다수의 메시지를 batch 형태로 broker 에세 한 번에 전달할 수 있어서 TCP/IP 라운드 트립 횟수를 줄일 수 있다. 
- Consumer 는 broker 로부터 직접 메시지를 가지고 가는 pull 방식으로 동작하기 때문에 자신의 처리 능력만큼의 메시지만 가져올 수 있기 때문에 최적의 
성능을 낼 수 있으며, 메시지를 쌓아두었다가 주기적으로 처리하는 batch consumer 를 구현할 수 있다. 

## 토픽
메시지를 받을 수 있도록 논리적으로 묶은 개념

## 파티션
토픽을 구성하는 데이터 저장소. 수평 확장이 가능한 단위로 병렬처리 방식으로 메시지를 보내어 빠른 전송이 가능하도록 한다. 

### 적당한 파티션의 수는?
파티션 수가 증가함에 따라 빠른 전송이 가능하기는 하지만, 토픽의 파티션 수를 무조건 많이 늘려주는 것은 오히려 좋지 않은 영향을 미칠 수 있다.

- 파일핸들러 낭비

각 파티션은 브로커의 디렉토리와 맵핑되고, 저장되는 데이터마다 2개의 파일(인덱스와 실제 데이터)이 있다. 카프카에서는 모든 디렉토리의 파일들에 
대해 파일 핸들을 열고, 따라서 파티션의 수가 많을 수록 파일 핸들 수 역시 많아지게 된다(리소스 낭비).

- 장애 복구 시간 증가

카프카의 리플리케이션은 토픽이 아닌 파티션 단위로 동작한다. 각 파티션 마다 리플리케이션이 동ㅈ가하며, 하나는 파티션의 리더가 되고 나머지는 
파티션의 팔로워가 된다. 

만약 브로커가 다운되면, 해당 브로커에 리더가 있는 파티션은 일시적으로 사용할 수 없게 되고카프카는 리더를 팔로워 중 하나로 이동시켜 클라이언트 요청을 
처리할 수 있게 한다. 이런 장애 처리는 컨트롤러로 지정된 브로커가 수행을 하게 되고, 컨트롤러는 카프카 클러스터 내에 하나만 존재한다. 
> 컨트롤러 역할을 수행하는 브로커가 다운되면 살아 있는 브로커 중 하나가 자동으로 컨트롤러 역할을 대신 수행한다. 

최악의 에러 상황으로 다운된 브로커가 컨트롤러인 경우, 컨트롤러가 살아있는 다른 브로커에게 완전히 넘어가기 전까지 새로운 리더를 선출할 수 없게 된다. 
컨트롤러의 failover 는 자동으로 동작하지만, 새 컨트롤러가 초기화되는 동안 **주키퍼에서 모든 파티션의 데이터를 읽어야 한다**.

파티션 수를 무작정 늘리다보면 예상치 못한 문제들이 발생할 수 있으므로 적잘한 값으로 설정해서 운영해주는 것이 좋다. 
카프카에서는 브로커당 약 2,000개 정도의 최대 파티션 수를 권장하고 있다. 

## 프로듀서의 메시지 전송 방법
### 메시지를 보내고 확인하지 않는 방법
프로듀서에서 서버로 메시지를 보내고 난 후에 성공 여부를 확인하지 않는다. 메시지 전송에 실패할 경우 프로듀서가 자동으로 재전송하기 때문에 대부분 
성공적으로 전송되지만 일부 메시지의 손실에 대해 보장하지 않는다. 
```java
Producer<String, String> producer = new KafkaProducer<>(props);
try {
  producer.send(new ProducerRecord<String, String>("test-topic", "Hello World!"));
} catch (Exception e) {
  // 브로커에게 메시지를 보낸 후의 에러는 무시하지만, 보내기 전에 에러가 발생하면 예외 처리 가능
  e.printStackTrace();
} finally {
  producer.close();
}
```

### 동기적으로 전송하는 방법
프로듀서는 메시지를 전송하고 `send()` 메소드의 `Future` 객체를 리턴한다. `get()` 메소드를 사용해서 `Future` 를 기다린 후 `send()`의 
성공 여부를 확인할 수 있다. 브로커에 전송한 메시지마다 확인하여 신뢰성있는 메시지 전송이 가능하다. 
```java
Producer<String, String> producer = new KafkaProducer<>(props);
try {
  // get() 메소드로 카프카의 응답을 기다림
  // 메시지가 성공적으로 전송되지 않으면 예외 발생
  RecordMetadata meta = producer.send(new ProducerRecord<String, String>("test-topic", "Hello World!")).get();
  System.out.printf("partition: %d, offset: %d", meta.partition(), meta.offset());
} catch (Exception e) {
  // 재시도가 가능한 예외: 커넥션 에러...
  // 재시도가 불가능한 예외: 메시지크기가 너무 큰 경우...
  e.printStackTrace();
} finally {
  producer.close();
}
```

### 비동기로 전송하는 방법
`send()` 메소드를 콜백과 같이 호출하고, 브로커에서 응답을 받으면 콜백한다. 동기적으로 메시지를 전송할 경우 모든 메시지에 대해 응답을 기다리게 
되기 때문에 전송시간이 더 많이 소요된다. 
비동기적으로 전송할 경우 응답을 기다리지 않기 때문에 더욱 빠른 전송이 가능하다. 메시지 전송에 실패한다면 예외 처리를 할 수 있다. 
```java
class MyCallback implements Callback {
  @Override
  public void onCompletion(RecordMetadata meta, Exception e) {
    if (e != null) {
      // 메시지 전송 실패 
    } else {
      // 메시지 전송 성공
    }
  }
}

...
// 프로듀서에서 레코드를 보낼 때 콜백 오브젝트도 같이 보냄
producer.send(new ProducerRecord<String, String>("test-topic", "Hello World!"), new MyCallback());
```
